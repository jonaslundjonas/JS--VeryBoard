<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VeryBoard</title>
    
    <!-- Load Material Design 3 Web Components -->
    <script type="importmap">
    {
      "imports": {
        "@material/web/": "https://esm.run/@material/web/"
      }
    }
    </script>
    <script type="module">
      import '@material/web/all.js';
      import {styles as typescaleStyles} from '@material/web/typography/md-typescale-styles.js';

      document.adoptedStyleSheets.push(typescaleStyles.styleSheet);
    </script>
    
    <!-- Load Fonts: Roboto (standard) and Material Icons (for icons) -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" rel="stylesheet">

    <!-- Flatpickr: A lightweight and powerful datetime picker -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

    <style>
        /* * MATERIAL 3 THEME & COLOR DEFINITIONS (LIGHT/DARK)
         */
        :root {
            --md-sys-color-primary: #6750A4;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #EADDFF;
            --md-sys-color-on-primary-container: #21005D;
            --md-sys-color-secondary: #625B71;
            --md-sys-color-on-secondary: #FFFFFF;
            --md-sys-color-secondary-container: #E8DEF8;
            --md-sys-color-on-secondary-container: #1D192B;
            --md-sys-color-tertiary: #7D5260;
            --md-sys-color-on-tertiary: #FFFFFF;
            --md-sys-color-tertiary-container: #FFD8E4;
            --md-sys-color-on-tertiary-container: #31111D;
            --md-sys-color-error: #B3261E;
            --md-sys-color-on-error: #FFFFFF;
            --md-sys-color-error-container: #F9DEDC;
            --md-sys-color-on-error-container: #410E0B;
            --md-sys-color-background: #FFFBFE;
            --md-sys-color-on-background: #1C1B1F;
            --md-sys-color-surface: #FFFBFE;
            --md-sys-color-on-surface: #1C1B1F;
            --md-sys-color-surface-variant: #E7E0EC;
            --md-sys-color-on-surface-variant: #49454F;
            --md-sys-color-outline: #79747E;
            --md-sys-color-outline-variant: #C4C7C5;
            --md-sys-color-shadow: #000000;
            --md-sys-color-scrim: #000000;
            --md-sys-color-inverse-surface: #313033;
            --md-sys-color-inverse-on-surface: #F4EFF4;
            --md-sys-color-inverse-primary: #D0BCFF;
            --md-sys-color-surface-dim: #DED8E1;
            --md-sys-color-surface-bright: #FFFBFE;
            --md-sys-color-surface-container-lowest: #FFFFFF;
            --md-sys-color-surface-container-low: #F7F2FA;
            --md-sys-color-surface-container: #F3EDF7;
            --md-sys-color-surface-container-high: #ECE6F0;
            --md-sys-color-surface-container-highest: #E6E0E9;
        }
        
        body.dark-mode {
            color-scheme: dark;
            --md-sys-color-primary: #D0BCFF;
            --md-sys-color-on-primary: #381E72;
            --md-sys-color-primary-container: #4F378B;
            --md-sys-color-on-primary-container: #EADDFF;
            --md-sys-color-secondary: #CCC2DC;
            --md-sys-color-on-secondary: #332D41;
            --md-sys-color-secondary-container: #4A4458;
            --md-sys-color-on-secondary-container: #E8DEF8;
            --md-sys-color-tertiary: #EFB8C8;
            --md-sys-color-on-tertiary: #492532;
            --md-sys-color-tertiary-container: #633B48;
            --md-sys-color-on-tertiary-container: #FFD8E4;
            --md-sys-color-error: #F2B8B5;
            --md-sys-color-on-error: #601410;
            --md-sys-color-error-container: #8C1D18;
            --md-sys-color-on-error-container: #F9DEDC;
            --md-sys-color-background: #1C1B1F;
            --md-sys-color-on-background: #E6E1E5;
            --md-sys-color-surface: #1C1B1F;
            --md-sys-color-on-surface: #E6E1E5;
            --md-sys-color-surface-variant: #49454F;
            --md-sys-color-on-surface-variant: #CAC4D0;
            --md-sys-color-outline: #938F99;
            --md-sys-color-outline-variant: #444746;
            --md-sys-color-shadow: #000000;
            --md-sys-color-scrim: #000000;
            --md-sys-color-inverse-surface: #E6E1E5;
            --md-sys-color-inverse-on-surface: #313033;
            --md-sys-color-inverse-primary: #6750A4;
            --md-sys-color-surface-dim: #141218;
            --md-sys-color-surface-bright: #3B383E;
            --md-sys-color-surface-container-lowest: #0F0D13;
            --md-sys-color-surface-container-low: #1C1B1F;
            --md-sys-color-surface-container: #211F26;
            --md-sys-color-surface-container-high: #2B2931;
            --md-sys-color-surface-container-highest: #36343B;
        }

        /* * BASE & LAYOUT STYLES
         */
        body {
            margin: 0;
            font-family: 'Roboto', sans-serif;
            background-color: var(--md-sys-color-background);
            color: var(--md-sys-color-on-background);
            transition: background-color 0.2s ease, color 0.3s ease;
        }

        .app-container {
            display: grid;
            /* Sidebar, Main Content */
            grid-template-columns: 280px 1fr;
            height: 100vh;
        }

        /* * SIDEBAR
         */
        .sidebar {
            display: flex;
            flex-direction: column;
            padding: 16px;
            gap: 20px;
            background-color: var(--md-sys-color-surface-container-low);
            border-right: 1px solid var(--md-sys-color-outline-variant);
            overflow-y: auto;
        }

        .sidebar h1 {
            font-size: 1.75rem;
            font-weight: 500;
            margin: 0 0 8px 0;
            color: var(--md-sys-color-primary);
        }

        .sidebar-section {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .sidebar-section h2 {
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--md-sys-color-on-surface-variant);
            text-transform: uppercase;
            margin: 0;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
        }

        .theme-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--md-sys-color-on-surface-variant);
        }
        
        .theme-toggle span {
            font-size: 0.9rem;
        }
        
        md-switch {
            --md-switch-selected-track-color: var(--md-sys-color-primary);
            --md-switch-selected-handle-color: var(--md-sys-color-on-primary);
            --md-switch-selected-hover-handle-color: var(--md-sys-color-on-primary);
            --md-switch-selected-pressed-handle-color: var(--md-sys-color-on-primary);
        }

        /* Ensure all buttons in sidebar take full width */
        .sidebar md-filled-button,
        .sidebar md-outlined-button {
            width: 100%;
        }

        /* * MAIN CONTENT (BOARD & FOOTER)
         */
        .main-content {
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevents whole page scroll */
        }

        .kanban-board {
            display: flex;
            flex-grow: 1; /* Takes up remaining vertical space */
            gap: 16px;
            padding: 24px;
            overflow-x: auto; /* Allows horizontal scrolling of lanes */
            background-color: var(--md-sys-color-surface);
        }

        .swim-lane {
            flex: 1; /* Each lane takes equal space */
            min-width: 320px;
            max-width: 360px;
            display: flex;
            flex-direction: column;
            background-color: var(--md-sys-color-surface-container);
            border-radius: 12px;
            border: 1px solid var(--md-sys-color-outline-variant);
            box-shadow: 0 1px 3px var(--md-sys-color-shadow-0-1);
        }

        .swim-lane h2 {
            font-size: 1.1rem;
            font-weight: 500;
            padding: 16px;
            margin: 0;
            color: var(--md-sys-color-on-surface);
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
        }

        .card-list {
            flex-grow: 1; /* Fills the lane */
            padding: 8px;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow-y: auto; /* Allows scrolling within a lane */
            border-radius: 0 0 12px 12px;
            transition: background-color: 0.2s ease;
        }
        
        .card-list.drag-over {
            /* Highlight lane when dragging over */
            background-color: var(--md-sys-color-primary-container);
        }

        .new-card-button {
            margin: 8px;
        }

        /* * KANBAN CARD
         */
        .kanban-card {
            display: block;
            padding: 12px;
            background-color: var(--md-sys-color-surface-container-high);
            border-radius: 8px;
            border: 1px solid var(--md-sys-color-outline-variant);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            cursor: grab;
            transition: box-shadow 0.2s ease, transform 0.2s ease, opacity 0.2s ease;
        }

        .kanban-card:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        }
        
        /* Style for the card being dragged */
        .kanban-card.dragging {
            opacity: 0.5;
            transform: rotate(3deg);
            cursor: grabbing;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .kanban-card h3 {
            font-size: 1rem;
            font-weight: 500;
            margin: 0 0 4px;
            color: var(--md-sys-color-on-surface);
        }
        
        .kanban-card p {
            font-size: 0.875rem;
            margin: 0 0 12px;
            color: var(--md-sys-color-on-surface-variant);
            white-space: pre-wrap; /* Respects newlines in description */
            word-break: break-word;
        }
        
        .card-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.75rem;
            color: var(--md-sys-color-on-surface-variant);
        }
        
        .card-footer .owner {
            font-weight: 500;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .card-footer .due-date.overdue {
            color: var(--md-sys-color-error);
            font-weight: 500;
        }

        .linked-cards-container {
            margin-bottom: 8px;
            font-size: 0.75rem;
        }

        .linked-card-badge {
            background-color: var(--md-sys-color-secondary-container);
            color: var(--md-sys-color-on-secondary-container);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            margin-right: 4px;
        }

        /* * MODAL (DIALOG) STYLES
         */
         #card-modal md-dialog {
            --md-dialog-container-color: var(--md-sys-color-surface-container-high);
         }
         
         #card-form {
            display: flex;
            flex-direction: column;
            gap: 16px;
            min-width: 400px;
         }
         
         /* Make text fields and text areas full width */
         #card-form md-text-field,
         #card-form md-filled-text-field {
            width: 100%;
         }

         .form-row {
             display: flex;
             gap: 16px;
         }

         .form-row > * {
             flex: 1;
         }

        .select-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .select-container label {
            font-size: 0.8rem;
            color: var(--md-sys-color-on-surface-variant);
            margin-left: 16px;
        }
         
         .form-info {
             font-size: 0.8rem;
             color: var(--md-sys-color-on-surface-variant);
         }
         
         /* Custom style for the delete button */
         #delete-button {
             --md-text-button-label-text-color: var(--md-sys-color-error);
             margin-right: auto; /* Pushes to the far left */
         }
         
         #reminders-modal ul {
             list-style-type: none;
             padding-left: 0;
         }
         
         #reminders-modal li {
             padding: 8px;
             border-bottom: 1px solid var(--md-sys-color-outline-variant);
         }
         #reminders-modal li:last-child {
             border-bottom: none;
         }
         
         #reminders-modal strong {
             color: var(--md-sys-color-primary);
         }

        #comment-toolbar {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            align-items: center;
        }

        #comment-toolbar button, #comment-toolbar select {
            border: 1px solid var(--md-sys-color-outline-variant);
            background-color: var(--md-sys-color-surface-container-low);
            color: var(--md-sys-color-on-surface-variant);
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
        }

        b, strong {
            font-weight: 900;
        }

        /* Ensure flatpickr calendar is on top of the modal */
        .flatpickr-calendar {
            z-index: 10000;
        }

        /* * FOOTER
         */
        footer {
            text-align: center;
            padding: 12px;
            font-size: 0.75rem;
            color: var(--md-sys-color-on-surface-variant);
            background-color: var(--md-sys-color-surface-container-low);
            border-top: 1px solid var(--md-sys-color-outline-variant);
        }

        /* Hidden file inputs */
        .hidden-file-input {
            display: none;
        }

        /* * RESPONSIVENESS
         */
        @media (max-width: 768px) {
            .app-container {
                /* Stack sidebar and main content vertically */
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr; /* Sidebar height auto, main content fills rest */
                height: auto; /* Allow page to scroll on mobile */
            }

            .sidebar {
                border-right: none;
                border-bottom: 1px solid var(--md-sys-color-outline-variant);
            }

            .kanban-board {
                padding: 16px;
                /* Horizontal scrolling is still the best for kanban on mobile */
            }
            
            #card-form {
                min-width: 80vw;
            }

            .form-row {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>

    <!-- Main App Layout -->
    <div class="app-container">
        
        <!-- Sidebar / Menu -->
        <aside class="sidebar">
            <h1>VeryBoard</h1>
            
            <div class="sidebar-section">
                <h2>Board</h2>
                <md-filled-button id="load-button">
                    Load Board
                    <span slot="icon" class="material-icons-outlined">folder_open</span>
                </md-filled-button>
                <md-outlined-button id="save-button">
                    Save Board
                    <span slot="icon" class="material-icons-outlined">save</span>
                </md-outlined-button>
                <md-filled-button id="load-card-button">
                    Load Card
                    <span slot="icon" class="material-icons-outlined">note_add</span>
                </md-filled-button>
            </div>
            
            <div class="sidebar-section">
                <h2>Settings</h2>
                <div class="theme-toggle">
                    <span>Dark Theme</span>
                    <md-switch id="theme-toggle"></md-switch>
                </div>
            </div>

            <div class="sidebar-section">
                <h2>Reminders</h2>
                <md-filled-button id="send-reminders-button">
                    Check Reminders
                    <span slot="icon" class="material-icons-outlined">notifications_active</span>
                </md-filled-button>
            </div>
            
            <!-- Hidden inputs for file operations -->
            <input type="file" id="file-loader" class="hidden-file-input" accept=".VBoard">
            <input type="file" id="card-loader" class="hidden-file-input" accept=".vbcard">
            <a id="file-saver" class="hidden-file-input"></a>
        </aside>

        <!-- Main Content Area -->
        <main class="main-content">
            
            <!-- Kanban Board -->
            <div id="board" class="kanban-board">
                
                <!-- Swim Lane: Idea -->
                <div class="swim-lane" id="lane-idea">
                    <h2>Idea</h2>
                    <div class="card-list" data-lane-id="idea">
                        <!-- Cards will be dynamically inserted here -->
                    </div>
                    <md-filled-tonal-button class="new-card-button" data-lane-id="idea">
                        New Card
                        <span slot="icon" class="material-icons-outlined">add</span>
                    </md-filled-tonal-button>
                </div>
                
                <!-- Swim Lane: To do -->
                <div class="swim-lane" id="lane-todo">
                    <h2>To do</h2>
                    <div class="card-list" data-lane-id="todo">
                        <!-- Cards will be dynamically inserted here -->
                    </div>
                    <md-filled-tonal-button class="new-card-button" data-lane-id="todo">
                        New Card
                        <span slot="icon" class="material-icons-outlined">add</span>
                    </md-filled-tonal-button>
                </div>
                
                <!-- Swim Lane: Ongoing -->
                <div class="swim-lane" id="lane-ongoing">
                    <h2>Ongoing</h2>
                    <div class="card-list" data-lane-id="ongoing">
                        <!-- Cards will be dynamically inserted here -->
                    </div>
                    <md-filled-tonal-button class="new-card-button" data-lane-id="ongoing">
                        New Card
                        <span slot="icon" class="material-icons-outlined">add</span>
                    </md-filled-tonal-button>
                </div>
                
                <!-- Swim Lane: Approved -->
                <div class="swim-lane" id="lane-approved">
                    <h2>Approved</h2>
                    <div class="card-list" data-lane-id="approved">
                        <!-- Cards will be dynamically inserted here -->
                    </div>
                    <md-filled-tonal-button class="new-card-button" data-lane-id="approved">
                        New Card
                        <span slot="icon" class="material-icons-outlined">add</span>
                    </md-filled-tonal-button>
                </div>
                
                <!-- Swim Lane: Done -->
                <div class="swim-lane" id="lane-done">
                    <h2>Done</h2>
                    <div class="card-list" data-lane-id="done">
                        <!-- Cards will be dynamically inserted here -->
                    </div>
                    <md-filled-tonal-button class="new-card-button" data-lane-id="done">
                        New Card
                        <span slot="icon" class="material-icons-outlined">add</span>
                    </md-filled-tonal-button>
                </div>

            </div>
            
            <!-- Footer -->
            <footer>
                <p>Created by Jonas Lund 2025</p>
            </footer>
        </main>
    </div>

    <!-- Card Editor Modal (Dialog) -->
    <md-dialog id="card-modal">
        <div slot="headline">Create / Edit Card</div>
        <form id="card-form" slot="content" method="dialog">
            
            <input type="hidden" id="card-id">
            <input type="hidden" id="card-lane-id">
            
            <md-outlined-text-field label="Title" id="card-title" required></md-outlined-text-field>

            <md-outlined-text-field label="Brief Description" id="card-description"></md-outlined-text-field>

            <label for="card-comment">Comment</label>
            <div id="comment-toolbar">
                <button type="button" data-command="bold"><b>B</b></button>
                <button type="button" data-command="italic"><i>I</i></button>
                <button type="button" data-command="insertUnorderedList">●</button>
                <select data-command="justify">
                    <option value="justifyLeft">Left</option>
                    <option value="justifyCenter">Center</option>
                    <option value="justifyRight">Right</option>
                    <option value="justifyFull">Justify</option>
                </select>
                <select data-command="fontSize">
                    <option value="1">Small</option>
                    <option value="3">Normal</option>
                    <option value="5">Large</option>
                    <option value="7">Huge</option>
                </select>
                <button type="button" data-command="createLink">Link</button>
            </div>
            <div id="card-comment" contenteditable="true" style="border: 1px solid #ccc; padding: 10px; min-height: 150px; white-space: pre-wrap;"></div>
            <textarea id="card-comment-hidden" style="display:none;"></textarea>

            <div class="form-row">
                <div class="select-container">
                    <label for="card-category">Card Category</label>
                    <md-outlined-select label="Category" id="card-category">
                        <md-select-option value="Epic">
                            <div slot="headline">Epic</div>
                        </md-select-option>
                        <md-select-option value="Story">
                            <div slot="headline">Story</div>
                        </md-select-option>
                        <md-select-option value="Task" selected>
                            <div slot="headline">Task</div>
                        </md-select-option>
                    </md-outlined-select>
                </div>
                <div class="select-container">
                    <label for="linked-cards">Linked Cards</label>
                    <md-outlined-select label="Linked Cards" id="linked-cards" multiple>
                        <span slot="end" class="material-icons-outlined">link</span>
                    </md-outlined-select>
                </div>
            </div>

            <div class="form-row">
                <md-outlined-text-field label="Owner (email)" type="email" id="card-owner"></md-outlined-text-field>
                <md-outlined-text-field type="text" id="card-due-date" label="Due Date"></md-outlined-text-field>
            </div>
            <div class="form-row">
                <md-outlined-text-field label="Days before due" type="number" value="3" min="0" id="card-reminder-days"></md-outlined-text-field>
            </div>
            <div class="form-row">
                <md-outlined-text-field label="Card Color" type="color" value="#FFFFFF" id="card-color"></md-outlined-text-field>
                <md-outlined-text-field label="Text Color" type="color" value="#000000" id="card-text-color"></md-outlined-text-field>
            </div>
            
            <div class="form-info">
                <span id="card-created-date"></span>
                <span id="card-reminder-date"></span>
            </div>

        </form>
        <div slot="actions">
            <md-text-button id="delete-button" title="Delete Card"><span class="material-icons-outlined">delete</span></md-text-button>
            <md-outlined-button id="send-single-reminder-button">Send Reminder</md-outlined-button>
            <md-outlined-button id="save-card-button">Save Card</md-outlined-button>
            <md-text-button form="card-form" value="cancel">Cancel</md-text-button>
            <md-filled-button form="card-form" value="save">Save to Board</md-filled-button>
        </div>
    </md-dialog>
    
    <!-- Reminders Modal (Dialog) -->
    <md-dialog id="reminders-modal">
        <div slot="headline">Upcoming Reminders</div>
        <div slot="content" id="reminders-list">
            <!-- Reminder list will be dynamically inserted here -->
        </div>
        <div slot="actions">
            <md-text-button value="ok" autofocus>OK</md-text-button>
        </div>
    </md-dialog>

    <!-- Snackbar for notifications -->
    <md-snackbar id="snackbar" label-text="Message"></md-snackbar>

    <script type="module">
        // Wait for Material Web Components to be defined and ready
        // We don't need DOMContentLoaded because the script is at the end of the body.
        customElements.whenDefined('md-filled-button').then(() => {
            
            // --- STATE ---
            let boardState = {
                    cards: [
                        // Example card for demonstration
                        {
                            id: 'card-1',
                            laneId: 'idea',
                            title: 'Implement Kanban Board',
                            description: 'Build the basic UI',
                            comment: 'Need to use Material Web Components.',
                            createdDate: new Date().toISOString(),
                            dueDate: '2025-10-30',
                            owner: 'jonas@example.com',
                            reminderDays: 3,
                            color: '#FFFFFF',
                            textColor: '#000000',
                            category: 'Epic',
                            linkedCards: []
                        },
                        {
                            id: 'card-2',
                            laneId: 'todo',
                            title: 'Add Drag and Drop',
                            description: 'Allow moving cards',
                            comment: '',
                            createdDate: new Date().toISOString(),
                            dueDate: '2025-10-28',
                            owner: 'test@example.com',
                            reminderDays: 2,
                            color: '#FFFFFF',
                            textColor: '#000000',
                            category: 'Story',
                            linkedCards: []
                        },
                        {
                            id: 'card-3',
                            laneId: 'ongoing',
                            title: 'Implement Save/Load',
                            description: 'Use local file system',
                            comment: 'File extension should be .VBoard',
                            createdDate: new Date().toISOString(),
                            dueDate: '2025-10-25',
                            owner: 'dev@example.com',
                            reminderDays: 1,
                            color: '#FFFFFF',
                            textColor: '#000000',
                            category: 'Task',
                            linkedCards: []
                        }
                    ],
                    lanes: ['idea', 'todo', 'ongoing', 'approved', 'done']
                };
                
                let currentlyDraggingCardId = null;
                let flatpickrInstance = null;

                // --- DOM ELEMENTS ---
                const board = document.getElementById('board');
                const cardModal = document.getElementById('card-modal');
                const cardForm = document.getElementById('card-form');
                const deleteButton = document.getElementById('delete-button');
                const snackbar = document.getElementById('snackbar');
                
                // Sidebar elements
                const themeToggle = document.getElementById('theme-toggle');
                const saveButton = document.getElementById('save-button');
                const loadButton = document.getElementById('load-button');
                const fileLoader = document.getElementById('file-loader');
                const fileSaver = document.getElementById('file-saver');
                const sendRemindersButton = document.getElementById('send-reminders-button');
                const remindersModal = document.getElementById('reminders-modal');
                const remindersList = document.getElementById('reminders-list');

                // --- FUNCTIONS ---
                
                /**
                 * Generates a simple UUID
                 */
                function generateUUID() {
                    return 'card-' + Math.random().toString(36).substring(2, 15);
                }
                
                /**
                 * Shows a snackbar notification
                 * @param {string} message - The message to display
                 */
                window.showSnackbar = function(message) {
                    snackbar.labelText = message;
                    snackbar.open = true; // Use the 'open' property instead of show()
                }

                /**
                 * Creates a DOM element for a card
                 * @param {object} card - The card object from boardState
                 * @returns {HTMLElement} - The card element
                 */
                function createCardElement(card) {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'kanban-card'; // Add class for styling
                    cardEl.draggable = true; // Make it draggable
                    cardEl.dataset.cardId = card.id;
                    cardEl.style.backgroundColor = card.color || '#FFFFFF';
                    
                    const today = new Date().setHours(0,0,0,0);
                    const dueDate = card.dueDate ? new Date(card.dueDate) : null;
                    let dueDateClass = '';
                    let dueDateStr = card.dueDate ? new Date(card.dueDate).toLocaleDateString() : 'No due date';

                    if (dueDate && dueDate.setHours(0,0,0,0) < today && card.laneId !== 'done') {
                        dueDateClass = 'overdue';
                        dueDateStr += ' (Overdue)';
                    }

                    // Set the card's content
                    cardEl.innerHTML = `
                    <h3>${card.title}</h3>
                        <p>${card.description}</p>
                        <div class="linked-cards-container"></div>
                        <div class="card-footer">
                            <span class="owner">${card.owner || 'Unassigned'}</span>
                            <span class="due-date ${dueDateClass}">${dueDateStr}</span>
                        </div>
                    `;

                const linkedCardsContainer = cardEl.querySelector('.linked-cards-container');
                const linkedCards = getLinkedCards(card.linkedCards);
                if (linkedCards.length > 0) {
                    const linkedLabel = document.createElement('strong');
                    linkedLabel.textContent = 'Linked: ';
                    linkedCardsContainer.appendChild(linkedLabel);
                    linkedCards.forEach(linkedCard => {
                        const span = document.createElement('span');
                        span.textContent = linkedCard.title;
                        span.className = 'linked-card-badge';
                        linkedCardsContainer.appendChild(span);
                    });
                }
                
                // Manually set the text color on specific elements to override styles
                if (card.textColor) {
                    cardEl.style.color = card.textColor;
                    const h3 = cardEl.querySelector('h3');
                    const p = cardEl.querySelector('p');
                    const footerSpans = cardEl.querySelectorAll('.card-footer span');
                    if (h3) h3.style.color = card.textColor;
                    if (p) p.style.color = card.textColor;
                    footerSpans.forEach(span => span.style.color = card.textColor);
                }

                // Add event listeners for drag-and-drop
                cardEl.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', card.id);
                    currentlyDraggingCardId = card.id;
                    // Add class after a tiny delay for browser to register drag
                    setTimeout(() => cardEl.classList.add('dragging'), 0);
                }); // <-- I've removed the confusing comment that was here.
            
            cardEl.addEventListener('dragend', () => {
                cardEl.classList.remove('dragging');
                    currentlyDraggingCardId = null;
                });
                
                // Add listener for editing
                cardEl.addEventListener('dblclick', () => openEditModal(card));
                
                return cardEl;
            }

            /**
             * Renders the entire board based on the current boardState
             */
            function renderBoard() {
                // Clear all lanes
                document.querySelectorAll('.card-list').forEach(lane => {
                    lane.innerHTML = '';
                });
                
                // Add cards to their respective lanes
                boardState.cards.forEach(card => {
                    const laneEl = document.querySelector(`.card-list[data-lane-id="${card.laneId}"]`);
                    if (laneEl) {
                        const cardEl = createCardElement(card);
                        laneEl.appendChild(cardEl);
                    }
                });
            }

            /**
             * Opens the modal to create or edit a card
             * @param {object | null} card - The card to edit, or null to create a new one
             * @param {string | null} defaultLaneId - The lane to add a new card to
             */
            function openEditModal(card = null, defaultLaneId = null) {
                cardForm.reset();
                const titleEl = document.getElementById('card-title');
                
                if (card) {
                    // Editing existing card
                    cardModal.querySelector('[slot="headline"]').textContent = 'Edit Card';
                    document.getElementById('card-id').value = card.id;
                    document.getElementById('card-lane-id').value = card.laneId;
                    titleEl.value = card.title;
                    document.getElementById('card-description').value = card.description;
                    document.getElementById('card-comment').innerHTML = card.comment;
                    document.getElementById('card-comment-hidden').value = card.comment;
                    document.getElementById('card-owner').value = card.owner;
                    document.getElementById('card-due-date').value = card.dueDate;
                    document.getElementById('card-reminder-days').value = card.reminderDays || 3;
                    document.getElementById('card-color').value = card.color || '#FFFFFF';
                    document.getElementById('card-text-color').value = card.textColor || '#000000';
                    document.getElementById('card-category').value = card.category || 'Task';
                    
                    const created = new Date(card.createdDate).toLocaleString();
                    document.getElementById('card-created-date').textContent = `Created: ${created}`;
                    
                    deleteButton.style.display = 'block';
                } else {
                    // Creating new card
                    cardModal.querySelector('[slot="headline"]').textContent = 'Create New Card';
                    document.getElementById('card-id').value = '';
                    document.getElementById('card-lane-id').value = defaultLaneId || 'idea'; // Default to 'idea'
                    document.getElementById('card-description').value = '';
                    document.getElementById('card-comment').innerHTML = '';
                    document.getElementById('card-reminder-days').value = 3;
                    document.getElementById('card-category').value = 'Task';
                    document.getElementById('card-created-date').textContent = '';
                    deleteButton.style.display = 'none';
                }
                
                // Update reminder date info
                updateReminderInfo(document.getElementById('card-due-date').value, document.getElementById('card-reminder-days').value);
                
                // Initialize flatpickr on the due date field
                const dueDateEl = document.getElementById('card-due-date');
                flatpickrInstance = flatpickr(dueDateEl, {
                    dateFormat: "Y-m-d",
                    altInput: true,
                    altFormat: "F j, Y",
                    static: true, // Render the calendar next to the input, not at the end of the body
                });

                cardModal.open = true; // Use the 'open' property instead of show()
                // Focus the title field
                setTimeout(() => titleEl.focus(), 100);

                // Initial population of linked cards
                const cardId = document.getElementById('card-id').value;
                const category = document.getElementById('card-category').value;
                updateLinkedCardsDropdown(cardId, category);
            }

            /**
             * Populates the linked cards dropdown based on the selected category
             * @param {string|null} currentCardId - The ID of the card being edited, or null for a new card
             * @param {string} category - The selected category ('Epic', 'Story', 'Task')
             */
            function updateLinkedCardsDropdown(currentCardId, category) {
                const linkedCardsEl = document.getElementById('linked-cards');
                const currentCard = boardState.cards.find(c => c.id === currentCardId);
                const currentLinkedIds = currentCard ? currentCard.linkedCards : [];

                linkedCardsEl.innerHTML = ''; // Clear existing options

                let linkableCards = [];
                if (category === 'Epic') {
                    // Epics can link to Stories
                    linkableCards = boardState.cards.filter(c => c.category === 'Story');
                } else if (category === 'Story') {
                    // Stories can link to Epics or Tasks
                    linkableCards = boardState.cards.filter(c => c.category === 'Epic' || c.category === 'Task');
                } else if (category === 'Task') {
                    // Tasks can link to Stories
                    linkableCards = boardState.cards.filter(c => c.category === 'Story');
                }

                // Filter out the current card itself
                if (currentCardId) {
                    linkableCards = linkableCards.filter(c => c.id !== currentCardId);
                }

                if (linkableCards.length === 0) {
                    linkedCardsEl.disabled = true;
                    // Add a disabled placeholder option
                    const option = document.createElement('md-select-option');
                    option.disabled = true;
                    option.innerHTML = `<div slot="headline">No linkable cards</div>`;
                    linkedCardsEl.appendChild(option);
                } else {
                    linkedCardsEl.disabled = false;
                    linkableCards.forEach(c => {
                        const option = document.createElement('md-select-option');
                        option.value = c.id;
                        if (currentLinkedIds.includes(c.id)) {
                             option.selected = true;
                        }
                        option.innerHTML = `<div slot="headline">${c.title}</div>`;
                        linkedCardsEl.appendChild(option);
                    });
                }
            }

            /**
             * Returns an array of card objects from an array of card IDs
             * @param {string[]} cardIds - An array of card IDs
             * @returns {object[]} - An array of card objects
             */
            function getLinkedCards(cardIds) {
                if (!cardIds || cardIds.length === 0) return [];
                return cardIds.map(id => boardState.cards.find(c => c.id === id)).filter(Boolean);
            }
            
            /**
             * Updates the reminder date info text in the modal
             * @param {string} dueDateString - The due date from the input (YYYY-MM-DD)
             */
            function updateReminderInfo(dueDateString, daysBeforeString) {
                const reminderInfoEl = document.getElementById('card-reminder-date');
                const daysBefore = parseInt(daysBeforeString);
                if (dueDateString && !isNaN(daysBefore)) {
                    const dueDate = new Date(dueDateString);
                    dueDate.setDate(dueDate.getDate() - daysBefore);
                    reminderInfoEl.textContent = `Reminder will be sent on: ${dueDate.toLocaleDateString()}`;
                } else {
                    reminderInfoEl.textContent = 'Set a due date to see reminder date.';
                }
            }
            
            /**
             * Saves the card data from the modal to the boardState
             */
            function saveCardFromModal() {
                const cardId = document.getElementById('card-id').value;
                const linkedCardsEl = document.getElementById('linked-cards');
                const selectedOptions = Array.from(linkedCardsEl.selectedOptions || []);
                const cardData = {
                    id: cardId || generateUUID(),
                    laneId: document.getElementById('card-lane-id').value,
                    title: document.getElementById('card-title').value,
                    description: document.getElementById('card-description').value,
                    comment: document.getElementById('card-comment-hidden').value,
                    owner: document.getElementById('card-owner').value,
                    dueDate: document.getElementById('card-due-date').value,
                    reminderDays: parseInt(document.getElementById('card-reminder-days').value) || 0,
                    color: document.getElementById('card-color').value,
                    textColor: document.getElementById('card-text-color').value,
                    category: document.getElementById('card-category').value,
                    linkedCards: selectedOptions.map(opt => opt.value),
                };

                if (cardId) {
                    // Update existing card
                    const index = boardState.cards.findIndex(c => c.id === cardId);
                    if (index > -1) {
                        // Preserve createdDate
                        cardData.createdDate = boardState.cards[index].createdDate;
                        boardState.cards[index] = cardData;
                    }
                    showSnackbar('Card updated!');
                } else {
                    // Create new card
                    cardData.createdDate = new Date().toISOString();
                    boardState.cards.push(cardData);
                    showSnackbar('Card created!');
                }
                
                renderBoard();
            }
            
            /**
             * Deletes the card currently being edited in the modal
             */
            function deleteCardFromModal() {
                const cardId = document.getElementById('card-id').value;
                if (cardId) {
                    boardState.cards = boardState.cards.filter(c => c.id !== cardId);
                    renderBoard();
                    cardModal.close(); // Manually close modal after deletion
                    showSnackbar('Card deleted.');
                }
            }

            /**
             * Saves a single card to a local .vbcard file
             */
            function saveCard() {
                const cardData = {
                    title: document.getElementById('card-title').value,
                    description: document.getElementById('card-description').value,
                    comment: document.getElementById('card-comment-hidden').value,
                    owner: document.getElementById('card-owner').value,
                    dueDate: document.getElementById('card-due-date').value,
                    reminderDays: parseInt(document.getElementById('card-reminder-days').value) || 0,
                    color: document.getElementById('card-color').value,
                    textColor: document.getElementById('card-text-color').value,
                };

                try {
                    const data = JSON.stringify(cardData, null, 2);
                    const blob = new Blob([data], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);

                    fileSaver.href = url;
                    const timestamp = new Date().toISOString().slice(0, 10);
                    fileSaver.download = `${cardData.title.replace(/\s/g, '_')}_${timestamp}.vbcard`;
                    fileSaver.click();

                    URL.revokeObjectURL(url);
                    showSnackbar('Card saved successfully!');
                } catch (error) {
                    console.error('Error saving card:', error);
                    showSnackbar('Error: Could not save card.');
                }
            }
            
            /**
             * Saves the entire boardState to a local .VBoard file
             */
            function saveBoard() {
                try {
                    const data = JSON.stringify(boardState, null, 2); // Pretty-print JSON
                    const blob = new Blob([data], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    
                    fileSaver.href = url;
                    const timestamp = new Date().toISOString().slice(0, 10);
                    fileSaver.download = `VeryBoard_${timestamp}.VBoard`;
                    fileSaver.click();
                    
                    URL.revokeObjectURL(url); // Clean up
                    showSnackbar('Board saved successfully!');
                } catch (error) {
                    console.error('Error saving board:', error);
                    showSnackbar('Error: Could not save board.');
                }
            }
            
            /**
             * Loads a .VBoard file from the user's computer
             * @param {Event} event - The file input change event
             */
            function loadBoard(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const loadedState = JSON.parse(e.target.result);
                        // Basic validation
                        if (loadedState && loadedState.cards && loadedState.lanes) {
                            boardState = loadedState;
                            renderBoard();
                            showSnackbar('Board loaded successfully!');
                        } else {
                            throw new Error('Invalid file format.');
                        }
                    } catch (error) {
                        console.error('Error loading board:', error);
                        showSnackbar('Error: Could not load board. File may be corrupt.');
                    }
                };
                reader.readAsText(file);
                
                // Reset file input to allow loading the same file again
                event.target.value = null;
            }

            /**
             * Loads a single .vbcard file from the user's computer
             * @param {Event} event - The file input change event
             */
            function loadCard(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const cardData = JSON.parse(e.target.result);
                        // Basic validation
                        if (cardData && cardData.title) {
                            const newCard = {
                                id: generateUUID(),
                                laneId: 'idea', // Default to 'idea' lane
                                createdDate: new Date().toISOString(),
                                ...cardData,
                            };
                            boardState.cards.push(newCard);
                            renderBoard();
                            showSnackbar('Card loaded successfully!');
                        } else {
                            throw new Error('Invalid file format.');
                        }
                    } catch (error) {
                        console.error('Error loading card:', error);
                        showSnackbar('Error: Could not load card. File may be corrupt.');
                    }
                };
                reader.readAsText(file);

                // Reset file input to allow loading the same file again
                event.target.value = null;
            }
            
            /**
             * Checks for cards that are due soon and shows a modal
             */
            window.checkReminders = function() {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                const upcomingCards = boardState.cards.filter(card => {
                    if (!card.dueDate || card.laneId === 'done' || card.reminderDays === undefined) {
                        return false;
                    }

                    const daysBefore = card.reminderDays;
                    const dueDate = new Date(card.dueDate);
                    dueDate.setHours(0, 0, 0, 0); // Normalize due date
                    
                    const reminderDate = new Date(dueDate);
                    reminderDate.setDate(dueDate.getDate() - daysBefore);

                    // Check if today is the reminder date
                    return reminderDate.getTime() === today.getTime();
                });
                
                if (upcomingCards.length === 0) {
                    showSnackbar('No upcoming reminders found.');
                    return;
                }
                
                remindersList.innerHTML = ''; // Clear previous list
                const list = document.createElement('ul');
                upcomingCards.forEach(card => {
                    const listItem = document.createElement('li');
                    listItem.innerHTML = `
                        <strong>${card.title}</strong> (Owner: ${card.owner || 'Unassigned'})
                        <br>
                        <small>Due: ${new Date(card.dueDate).toLocaleDateString()}</small>
                    `;
                    listItem.style.cursor = 'pointer';
                    listItem.addEventListener('click', () => {
                        remindersModal.close();
                        openEditModal(card);
                    });
                    list.appendChild(listItem);
                });

                remindersList.appendChild(list);
                remindersModal.open = true;
            }

            /**
             * Triggers the user's default email client for a single card reminder.
             * @param {object} card - The card object to send a reminder for.
             */
            function triggerEmailClientForCard(card) {
                // If in test mode, don't trigger the email client
                if (document.body.dataset.testMode === 'true') {
                    console.log('Test mode: triggerEmailClientForCard mocked. Card:', card);
                    window.emailClientTriggered = true;
                    return;
                }

                if (!card.owner || card.owner === 'Unassigned') {
                    showSnackbar('Cannot send reminder: Card has no owner.');
                    return;
                }

                const subject = `Reminder: Task "${card.title}" is due soon`;
                let body = `Hello,\n\nThis is a reminder for the following task:\n\n`;
                body += `  - Task: ${card.title}\n`;
                body += `    Description: ${card.description}\n`;
                body += `    Due Date: ${new Date(card.dueDate).toLocaleDateString()}\n\n`;
                body += `Thank you,\nVeryBoard`;

                const mailtoLink = `mailto:${card.owner}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;

                showSnackbar('Opening your email client to send reminder...');
                window.location.href = mailtoLink;
            }

            // --- EVENT LISTENERS ---
            
            // Theme Toggle
            themeToggle.addEventListener('change', (e) => {
                document.body.classList.toggle('dark-mode', e.target.selected);
            });
            
            // Save/Load Buttons
            saveButton.addEventListener('click', saveBoard);
            loadButton.addEventListener('click', () => fileLoader.click());
            fileLoader.addEventListener('change', loadBoard);
            const cardLoader = document.getElementById('card-loader');
            document.getElementById('load-card-button').addEventListener('click', () => cardLoader.click());
            cardLoader.addEventListener('change', loadCard);
            
            // Reminder Button
            sendRemindersButton.addEventListener('click', checkReminders);
            
            // "New Card" Buttons
            document.querySelectorAll('.new-card-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const laneId = e.currentTarget.dataset.laneId; // Use currentTarget
                    openEditModal(null, laneId);
                });
            });
            
            // Card Modal
            cardModal.addEventListener('close', (e) => {
                // Destroy the flatpickr instance to prevent memory leaks
                if (flatpickrInstance) {
                    flatpickrInstance.destroy();
                    flatpickrInstance = null;
                }

                // Check if the dialog was closed by the "Save" button
                if (cardModal.returnValue === 'save') {
                    saveCardFromModal();
                }
                // Always reset return value
                cardModal.returnValue = 'cancel';
            });
            
            // Modal Delete Button
            deleteButton.addEventListener('click', deleteCardFromModal);
            document.getElementById('save-card-button').addEventListener('click', saveCard);

            document.getElementById('send-single-reminder-button').addEventListener('click', () => {
                const cardId = document.getElementById('card-id').value;
                if (cardId) {
                    const card = boardState.cards.find(c => c.id === cardId);
                    if (card) {
                        triggerEmailClientForCard(card);
                    }
                } else {
                    showSnackbar('Save the card before sending a reminder.');
                }
            });
            
            // The built-in form submission for md-dialog seems to be unreliable in this setup.
            // We will manually handle the save and close action with a direct click listener.
            document.querySelector('md-filled-button[form="card-form"][value="save"]').addEventListener('click', (e) => {
                e.preventDefault(); // Stop the default form submission
                saveCardFromModal();
                cardModal.close(); // Manually close the dialog
            });

            // Add event listener for category change
            document.getElementById('card-category').addEventListener('change', (e) => {
                const cardId = document.getElementById('card-id').value;
                updateLinkedCardsDropdown(cardId, e.target.value);
            });

            // Update reminder info when due date or reminder days change
            document.getElementById('card-due-date').addEventListener('input', (e) => updateReminderInfo(e.target.value, document.getElementById('card-reminder-days').value));
            document.getElementById('card-reminder-days').addEventListener('input', (e) => updateReminderInfo(document.getElementById('card-due-date').value, e.target.value));

            // Comment Rich Text Editor Toolbar
            document.getElementById('card-comment').addEventListener('input', () => {
                document.getElementById('card-comment-hidden').value = document.getElementById('card-comment').innerHTML;
            });

            // --- Rich Text Editor Logic ---
            const toolbar = document.getElementById('comment-toolbar');
            const commentEditor = document.getElementById('card-comment');
            const hiddenComment = document.getElementById('card-comment-hidden');

            function applyFormat(command, value = null) {
                // We don't need to focus the editor here, as the mousedown prevention
                // should keep the focus and selection intact.
                document.execCommand(command, false, value);
                // Manually sync the hidden input after applying the format
                hiddenComment.value = commentEditor.innerHTML;
            }

            // For buttons, we use 'mousedown' to prevent them from stealing focus
            // from the contenteditable div, which would deselect the text.
            toolbar.querySelectorAll('button').forEach(button => {
                button.addEventListener('mousedown', e => {
                    e.preventDefault(); // This is the key to prevent focus shift

                    const command = button.dataset.command;
                    if (command === 'createLink') {
                        const url = prompt('Enter a URL:');
                        if (url) applyFormat(command, url);
                    } else {
                        applyFormat(command);
                    }
                });
            });

            // For select elements, 'change' is the appropriate event to get the new value.
            // They don't have the same focus-stealing issue as buttons.
            toolbar.querySelectorAll('select').forEach(select => {
                select.addEventListener('change', e => {
                    const command = select.dataset.command;
                    if (command === 'justify') {
                        // For justification, the command is the value itself.
                        applyFormat(select.value);
                    } else {
                        applyFormat(command, select.value);
                    }
                });
            });

            // Drag-and-Drop Listeners for Swim Lanes
            document.querySelectorAll('.card-list').forEach(lane => {
                lane.addEventListener('dragover', (e) => {
                    e.preventDefault(); // Allow drop
                    lane.classList.add('drag-over');
                });
                
                lane.addEventListener('dragleave', () => {
                    lane.classList.remove('drag-over');
                });
                
                lane.addEventListener('drop', (e) => {
                    e.preventDefault();
                    lane.classList.remove('drag-over');
                    
                    const cardId = e.dataTransfer.getData('text/plain');
                    // Ensure we're not dropping on a card, but on the list
                    const targetLane = e.target.closest('.card-list'); 
                    
                    if (cardId && targetLane) {
                        const newLaneId = targetLane.dataset.laneId;
                        const card = boardState.cards.find(c => c.id === cardId);
                        
                        if (card && card.laneId !== newLaneId) {
                            card.laneId = newLaneId;
                            renderBoard(); // Re-render state
                        }
                    }
                });
            });

            // --- INITIALIZATION ---
            renderBoard();
            showSnackbar('Welcome to VeryBoard!');

        }); // End of customElements.whenDefined
    </script>
</body>
</html>
